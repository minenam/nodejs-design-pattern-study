Generator란 무엇인가?

Generator 는 "일시 중지했다가 다시 재개할 수 있는 함수"

일반 함수의 경우 한번 실행하면 끝까지 실행되지만, Generator 함수는 중단에 멈췄다가 나중에 이어서 실행할 수 있다.

```javascript
// Generator 함수 선언
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

// Generator 함수를 호출하면 Iterator 객체를 반환
const gen = generator();

// next()를 호출할 때마다 다음 yield 까지 실행
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

Generator 함수는 `function*` 키워드를 사용하여 선언한다.

Generator 함수는 `yield` 키워드를 사용하여 값을 반환한다. `yield` 키워드를 만나면 해당 값을 반환하고 함수의 실행을 일시 중지한다.

## 핵심 개념

1. `function*` - Generator 함수 선언

```javascript
function* gen() {
  //Generator 함수
}
```

`*` 기호로 일반 함수와 구분

2. `yield` - 일시 중지 포인트

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
```

`yield` 키워드를 만나면

- 현재 실행 위치와 변수 상태를 저장
- 함수 실행을 일시 중지
- `yield` 뒤의 값을 반환

3. `next()` - 다음 yield 까지 실행

```javascript
const counter = gen();

counter.next(); // { value: 1, done: false }
counter.next(); // { value: 2, done: false }
counter.next(); // { value: 3, done: false }
counter.next(); // { value: undefined, done: true }
```

`next()` 를 호출하면

- 이전에 멈춘 위치부터 재개
- 다음 `yield` 까지 실행
- 결과를 `{ value, done }` 형태로 반환

## Generator 기능

1. 양방향 통신

Generator 함수는 값을 받을 수도 있음

```javascript
function* conversation() {
  const name = yield "이름이 뭐예요?";
  const age = yield "나이가 어떻게 되세요?";
  return `${name}님은 ${age}살이군요!`;
}

const conv = conversation();

console.log(conv.next()); // { value: "이름이 뭐예요?", done: false }
console.log(conv.next("철수")); // { value: "나이가 어떻게 되세요?", done: false }
console.log(conv.next(25)); // { value: "철수님은 25살이군요!", done: true }
```

핵심 -> `next(value)` 의 `value`는 이전 `yield` 표현식의 값이 됨

```javascript
function* example() {
  const a = yield; // a에는 다음 next()의 인자가 들어감
  console.log(a); // 'hello' 출력
}

const gen = example();
gen.next(); // 첫 yield까지 실행
gen.next("hello"); // a = 'hello'가 되고 console.log 실행
```

2. 이터레이터 프로토콜 구현

Generator 함수는 이터레이터 프로토콜을 자동으로 구현함

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
```

이터레이터 프로토콜을 구현하면 해당 객체를 `for...of` 문으로 순회할 수 있다.

```javascript
for (const value of gen()) {
  console.log(value);
}
```

이터레이터 프로토콜을 구현하면 해당 객체를 `...` 연산자로 펼칠 수 있다.

```javascript
const arr = [...gen()];
console.log(arr); // [1, 2, 3]
```

3. 에러 전달

Generator 함수는 `throw()` 메서드를 사용하여 에러를 전달할 수 있다.

```javascript
function* gen() {
  try {
    yield 1;
  } catch (error) {
    console.log(error);
  }
}

const gen = gen();
gen.next(); // { value: 1, done: false }
gen.throw(new Error("에러")); // Error: 에러 출력
gen.next(); // { value: undefined, done: true }
```

## Generator와 asnyc/await 관계

Generator로 비동기 흉내내기

```javascript
// Generator로 비동기 흉내내기
function* fetchUserData() {
  const user = yield fetch("/api/user"); // 여기서 멈춤
  const posts = yield fetch("/api/posts"); // 여기서 멈춤
  return { user, posts };
}

// 이것을 자동으로 실행하는 런타임을 만들면?
function runAsync(genFunc) {
  const gen = genFunc();

  function handle(result) {
    if (result.done) return Promise.resolve(result.value);

    // result.value는 Promise (fetch의 반환값)
    return result.value.then((data) => {
      return handle(gen.next(data)); // Promise 완료되면 재개!
    });
  }

  return handle(gen.next());
}

// 사용
runAsync(fetchUserData).then((result) => {
  console.log(result);
});
```

이 코드가 async/await 의 원리

```javascript
// 위의 코드는 이 코드와 동일
async function fetchUserData() {
  const user = await fetch("/api/user");
  const posts = await fetch("/api/posts");
  return { user, posts };
}
```

## 왜 async/await 의 기반인가?

Generator의 일시 중지/재기 + Promise의 비동기 완료 알림
= 비동기 코드를 동기처럼 작성 가능
= async/await

## 근데 우리가 실무에서 Generator를 사용할 일이 있을까?

과거에는 한번도 쓸 일이 없었는데, 요즘은 한번씩 사용되는 것 같다.

case 1. s3에서 대용량 파일을 청크 단위로 다운로드할 때

```javascript
const { S3Client, GetObjectCommand } = require("@aws-sdk/client-s3");

// Range Request로 청크 단위 다운로드
async function* downloadS3InChunks(bucket, key, chunkSize = 5 * 1024 * 1024) {
  const s3 = new S3Client({ region: "us-east-1" });

  // 파일 크기 확인
  const headCommand = new HeadObjectCommand({ Bucket: bucket, Key: key });
  const { ContentLength } = await s3.send(headCommand);

  let start = 0;

  while (start < ContentLength) {
    const end = Math.min(start + chunkSize - 1, ContentLength - 1);

    // 5MB씩 다운로드
    const command = new GetObjectCommand({
      Bucket: bucket,
      Key: key,
      Range: `bytes=${start}-${end}`,
    });

    const { Body } = await s3.send(command);
    yield Body; // 5MB 청크 반환

    start = end + 1;
  }
}

// 100GB 파일을 메모리 5MB만 사용하면서 청크 단위로 다운로드
for await (const chunk of downloadS3InChunks("my-bucket", "huge-file.csv")) {
  await processChunk(chunk);
}
```

case 2. elasticsearch에서 대용량 데이터를 청크 단위로 읽어올 때

```javascript
const { Client } = require("@elastic/elasticsearch");

async function* searchAllDocuments(index, query) {
  const client = new Client({ node: "http://localhost:9200" });

  // 초기 검색 (scroll 시작)
  let response = await client.search({
    index,
    scroll: "1m",
    size: 1000,
    body: { query },
  });

  yield response.hits.hits; // 첫 1000개

  // scroll로 나머지 가져오기
  while (response.hits.hits.length > 0) {
    response = await client.scroll({
      scroll_id: response._scroll_id,
      scroll: "1m",
    });

    if (response.hits.hits.length === 0) break;

    yield response.hits.hits; // 다음 1000개
  }

  // scroll 정리
  await client.clearScroll({
    scroll_id: response._scroll_id,
  });
}

// 천만 개 문서도 1000개씩 처리
for await (const docs of searchAllDocuments("logs", { match_all: {} })) {
  console.log(`Processing ${docs.length} documents`);
  await indexToOtherDB(docs);
}
```

이런 형태로 주로 사용하고 있다.
