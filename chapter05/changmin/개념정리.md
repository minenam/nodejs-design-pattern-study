## 핵심 개념: "순회"의 진화

모든 것은 **"데이터를 하나씩 꺼내는(순회하는) 표준 방법"**이 필요해서 시작된 컨셉

---

## 1. Iterator (ES6, 2015) - 순회의 표준화

### 등장 배경: 문제 상황

```javascript
// ES5 시절 - 각자 다른 방식으로 순회
const array = [1, 2, 3];
for (let i = 0; i < array.length; i++) {} // 배열

const obj = { a: 1, b: 2 };
for (let key in obj) {
} // 객체

const map = new Map();
map.forEach((value, key) => {}); // Map
```

**문제:** 자료구조마다 순회 방법이 다름 → 일관성 없음

### 해결: Iterator Protocol

```javascript
// Iterator Protocol: 단 하나의 규칙
// "next() 메서드를 가지고, { value, done }을 반환"

const iterator = {
  current: 0,
  next() {
    if (this.current < 3) {
      return { value: this.current++, done: false };
    }
    return { done: true };
  },
};

console.log(iterator.next()); // { value: 0, done: false }
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { done: true }
```

### 왜 중요한가?

**for...of가 작동하는 원리**

```javascript
const arr = [1, 2, 3];

// 내부적으로 이렇게 동작
const iterator = arr[Symbol.iterator]();
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { done: true }
```

**MDN 정의:**

> "Iterator는 시퀀스를 정의하고 종료 시 반환값을 제공하는 객체"

---

## 2. Generator (ES6, 2015) - Iterator를 쉽게 만들기

### 등장 배경: Iterator 작성이 너무 복잡함

```javascript
// Iterator 직접 구현 - 복잡함
const rangeIterator = {
  current: 0,
  end: 5,
  [Symbol.iterator]() {
    return {
      current: this.current,
      end: this.end,
      next() {
        if (this.current < this.end) {
          return { value: this.current++, done: false };
        }
        return { done: true };
      },
    };
  },
};

//  Generator - 간단함!
function* range(start, end) {
  for (let i = start; i < end; i++) {
    yield i;
  }
}
```

### Generator = Iterator Factory

Generator는 **Iterator를 생성하는 함수**

```javascript
function* simpleGen() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = simpleGen(); // Generator 객체 = Iterator

// Iterator Protocol을 따름
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { done: true }
```

### 핵심 특징: 일시 중지/재개

```javascript
function* pausableFunction() {
  console.log("시작");
  yield 1;
  console.log("재개");
  yield 2;
  console.log("끝");
}

const gen = pausableFunction();
gen.next(); // '시작' 출력, { value: 1, done: false }
// 여기서 멈춤!
gen.next(); // '재개' 출력, { value: 2, done: false }
gen.next(); // '끝' 출력, { done: true }
```

**MDN 정의**

> "Generator 함수는 빠져나갔다가 나중에 다시 돌아올 수 있는 함수. 이때 컨텍스트(변수 값)는 출입 과정에서 저장됨"

---

## 3. AsyncIterator (ES2018) - 비동기 순회

### 등장 배경: Promise 시대의 순회 문제

```javascript
// Iterator는 동기만 가능
const syncIterator = {
  next() {
    return { value: 1, done: false };
  },
};

// 비동기를 이렇게 하면?
const brokenIterator = {
  async next() {
    const data = await fetchData(); // Promise
    return { value: data, done: false };
  },
};

// for...of는 비동기를 못 기다림!
// for (const item of brokenIterator) {} // 작동 안함!
```

### 해결: AsyncIterator Protocol

```javascript
// AsyncIterator Protocol
// "next()가 Promise<{ value, done }>를 반환"

const asyncIterator = {
  async next() {
    const data = await fetch("/api/data");
    return { value: data, done: false };
  },
  [Symbol.asyncIterator]() {
    return this;
  },
};

// for await...of로 사용
for await (const item of asyncIterator) {
  console.log(item); // 비동기 대기!
}
```

### 실제 예: 데이터베이스 페이징

```javascript
class DBPaginator {
  constructor(query) {
    this.query = query;
    this.offset = 0;
  }

  async next() {
    const results = await this.query.limit(100).offset(this.offset).execute();

    if (results.length === 0) {
      return { done: true };
    }

    this.offset += 100;
    return { value: results, done: false };
  }

  [Symbol.asyncIterator]() {
    return this;
  }
}

// 사용
const paginator = new DBPaginator(db.select("users"));

for await (const batch of paginator) {
  console.log(`Processing ${batch.length} users`);
  await processBatch(batch);
}
```

**MDN 정의**

> "AsyncIterator는 비동기 작업의 시퀀스를 생성하는 객체"

---

## 4. AsyncGenerator (ES2018) - 비동기 + 간편함

### 등장 배경: AsyncIterator도 복잡함

```javascript
// AsyncIterator 직접 구현 - 복잡
class AsyncRange {
  constructor(start, end) {
    this.current = start;
    this.end = end;
  }

  async next() {
    await new Promise((r) => setTimeout(r, 1000));

    if (this.current < this.end) {
      return { value: this.current++, done: false };
    }
    return { done: true };
  }

  [Symbol.asyncIterator]() {
    return this;
  }
}

//  AsyncGenerator - 간단
async function* asyncRange(start, end) {
  for (let i = start; i < end; i++) {
    await new Promise((r) => setTimeout(r, 1000));
    yield i;
  }
}
```

### AsyncGenerator = AsyncIterator Factory

```javascript
async function* fetchPages(url) {
  let page = 1;

  while (true) {
    // 비동기 작업
    const response = await fetch(`${url}?page=${page}`);
    const data = await response.json();

    if (data.length === 0) break;

    yield data; // 비동기 결과를 yield
    page++;
  }
}

// 사용
for await (const pageData of fetchPages("/api/users")) {
  console.log(pageData);
}
```

**MDN 정의**

> "AsyncGenerator 함수는 async function과 generator를 결합한 것으로, await와 yield를 모두 사용할 수 있음"

---

## 개념 간의 관계

```
Iterator (ES6)
    ↓
    문제: Iterator 만들기 복잡함
    ↓
Generator (ES6) = Iterator를 쉽게 만드는 문법
    ↓
    문제: 비동기 처리 불가
    ↓
AsyncIterator (ES2018) = Iterator + Promise
    ↓
    문제: AsyncIterator 만들기 복잡함
    ↓
AsyncGenerator (ES2018) = AsyncIterator를 쉽게 만드는 문법
                        = Generator + async/await
```

## 각각이 해결하는 문제

### Iterator

**문제:** 자료구조마다 순회 방법이 다름  
**해결:** 표준화된 순회 인터페이스

```javascript
// 모든 것을 for...of로 순회 가능
for (const item of array) {
}
for (const item of map) {
}
for (const item of set) {
}
for (const item of customIterator) {
}
```

### Generator

**문제:** Iterator 구현이 복잡함  
**해결:** `function*`와 `yield`로 간단히 구현

```javascript
// Iterator 100줄 → Generator 10줄
function* simple() {
  yield 1;
  yield 2;
}
```

### AsyncIterator

**문제:** 비동기 데이터를 순회할 방법이 없음  
**해결:** Promise를 반환하는 Iterator

```javascript
// 비동기 데이터 순회
for await (const data of asyncStream) {
  // 각 데이터를 기다림
}
```

### AsyncGenerator

**문제:** AsyncIterator 구현이 복잡함  
**해결:** `async function*`로 간단히 구현

```javascript
// AsyncIterator 100줄 → AsyncGenerator 10줄
async function* fetchData() {
  yield await fetch("/api/1");
  yield await fetch("/api/2");
}
```

## 실전 비유

**식당 비유로 이해하기:**

### Iterator (주문 번호판)

```
손님: "주문 번호 1번!"
직원: "여기 있습니다" (완료)
손님: "주문 번호 2번!"
직원: "여기 있습니다" (완료)
```

→ 순서대로 하나씩 받기

### Generator (자동 호출기)

```
[삐- 1번 손님] (자동으로 호출)
[삐- 2번 손님] (자동으로 호출)
```

→ 알아서 다음 거 준비해줌

### AsyncIterator (배달 앱)

```
손님: "주문 1"
앱: "준비 중... 완료!" (30분 후)
손님: "주문 2"
앱: "준비 중... 완료!" (30분 후)
```

→ 기다려야 하는 순서

### AsyncGenerator (자동 배달 주문)

```
앱: [자동으로 1번 주문 → 대기 → 배달]
앱: [자동으로 2번 주문 → 대기 → 배달]
```

→ 알아서 기다렸다가 다음 거

## 정리

| 개념               | 언제       | 특징                    | 용도                 |
| ------------------ | ---------- | ----------------------- | -------------------- |
| **Iterator**       | ES6 (2015) | 순회 표준               | `for...of`           |
| **Generator**      | ES6 (2015) | Iterator 간편 작성      | 무한 수열, ID 생성   |
| **AsyncIterator**  | ES2018     | 비동기 순회             | `for await...of`     |
| **AsyncGenerator** | ES2018     | AsyncIterator 간편 작성 | API 페이징, 스트리밍 |

**핵심 흐름:**

```
표준화(Iterator) → 간편화(Generator) → 비동기 지원(AsyncIterator) → 비동기 간편화(AsyncGenerator)
```
