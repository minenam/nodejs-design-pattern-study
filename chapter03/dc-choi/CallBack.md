## CallBack
비동기 작업의 결과를 가지고 런타임에 의해 호출되는 함수.

모든 비동기 매커니즘을 기초로 하는 것들의 가장 기본적인 구성요소

동기적으로 사용되는 return의 사용을 대신 할 수 있음.

그 이유는 함수가 일급 클래스 객체이기 때문.

콜백을 구현하는 또 다른 이상적 구조는 클로저(closure).

```ts
const func = (callback: (result: string) => void) => {
  setTimeout(() => {
    callback("작업 완료");
  }, 1000);
};

func((result) => {
  console.log(result); // "작업 완료"
});
```

### 연속 전달 방식
JS에서 콜백은 다른 함수에 인자로 전달되는 함수이며, 작업이 완료되면 작업 결과를 가지고 호출

함수형 프로그래밍에서 이런식으로 결과를 전달하는 방식을 연속 전달 방식(CPS: continuation-passing style)이라고 부름.

#### 동기식 연속 전달 방식
```js
const add = (a, b) => {
    return a + b;
};
```

이 경우 결과가 return을 통해 호출자에게 전달됨. 이것을 직접 스타일이라고 하고 동기식 프로그래밍에서 일반적으로 결과를 반환하는 방식임.

앞의 함수와 동일한 처리를 CPS로 바꾼 코드는 다음과 같음.

```js
const addCps = (a, b, callback) => {
    callback(a + b);
};
```

addCps() 함수는 동기 CPS 함수로 콜백 또한 작업이 완료되었을 때 작업을 완료함.

### 비동기 연속 전달 방식
```js
const additionAsync = (a, b, callback) => {
    setTimeout(() => callback(a + b), 100)
}
```

setTimeout() 은 이벤트 큐에 주어진 밀리초 후에 실행되는 작업을 추가함. 이는 명백한 비동기 작업임.

비동기 작업을 실행시키기 때문에 콜백의 실행이 끝날 때까지 기다리지 않는 대신,

즉시 반환되어 additionAsync()로 제어를 돌려주어 제어가 호출자에게 반환.

Node.js의 이 속성은 매우 중요한데 그 이유는 비동기 요청이 전달된 후

즉시 제어를 이벤트 루프에 돌려주고 큐(대기열)에 있는 새로운 이벤트가 처리될 수 있도록 하기 때문.

### 비 연속 전달(Non-CPS) 콜백
콜백 인자가 있는 경우 함수가 비동기식이거나 연속 전달 스타일(CPS)을 사용한다고 생각할 수 있음.

항상 그런 것은 아님. 예시로 Array.map()의 예시는 다음과 같음.

```js
const result = [1, 5, 7].map(element => element - 1)
console.log(result) // [0, 4, 6]
```

callback은 배열 내의 요소를 반복하는데 사용될 뿐 연산 결과를 전달하지 않음.

실제로 여기 결과는 직접적인 방식으로 동기적으로 반환됨.

## 동기? 비동기?
함수가 동기식인지 비동기식인지에 따라 실행 순서가 완전히 바뀌게 됨.

일반적으로 반드시 피해야 할 것은 API의 이러한 특성과 관련하여 발견하기 어렵고 재현 불가능한 문제를 일으키는 모순과 혼돈을 만드는 것.

### 예측할 수 없는 함수
가장 위험한 상황 중 하나는 특정 조건에서 동기적으로 동작하고 다른 조건에서는 비동기적으로 동작하는 로직을 구현하는 것.

```js
import { readFile } from 'fs'

const cache = new Map()

const inconsistentRead = (filename, cb) => {
    if (cache.has(filename)) {
        // 동기적으로 호출됨
        cb(cache.get(filename))
    } else {
        // 비동기 함수
        readFile(filename, 'utf8', (err, data) => {
            cache.set(filename, data)
            cb(data)
        })
    }
}
```

위 함수는 파일이 처음 읽혀지고 캐싱이 될 떄는 비동기로 처리됨.

캐시에 있는 경우 파일에 대한 후속처리는 동기적으로 동작하게 됨.

### 동기 API의 사용
API의 동기 또는 비동기 특성을 명확하게 정의하는 것이 필수

함수가 동기식이면 함수가 CPS를 가질 이유가 없음.

비동기 API 대신 동기 API를 사용하는 경우 몇가지 주의 사항
1. 특정 기능에 대한 동기식 API를 항상 사용할 수 있는 것은 아님.
2. 동기 API는 이벤트루프를 Block하고 동시 요청을 보류 함.

파일 I/O의 예시로 한 번이라도 큰 파일을 읽는 경우라면 이야기가 완전 달라짐.

Node.js에서 동기 I/O를 사용하는 것은 많은 경우에 권장되지 않음.

어떤 경우에는 가장 쉽고 효율적인 해결책이 되기도 하지만,

어플리케이션이 비동기적 동시성 작업을 처리하는데 영향을 주지 않는 경우만 동기 API를 사용할 것.

### 지연 실행으로 비동시성을 보장
함수를 수정하는 또 다른 방법은 완전한 비동기로 만드는 것.

여기서는 동일한 이벤트 루프 사이클에서 즉시 실행시키는 대신 가까운 미래에 실행되도록 예약하는 것.

Node.js에서는 process.nextTick()을 사용해서 이 작업을 수행함. 다음 예시는 process.nextTick()를 적용한 것.

```js
import { readFile } from 'fs'

const cache = new Map()

const inconsistentRead = (filename, cb) => {
    if (cache.has(filename)) {
        // 지연된 콜백 호출
        process.nextTick(() => cb(cache.get(filename)))
    } else {
        // 비동기 함수
        readFile(filename, 'utf8', (err, data) => {
            cache.set(filename, data)
            cb(data)
        })
    }
}
```

이처럼 process.nextTick()을 사용해서 실행을 연기함으로서 콜백의 비동기적 호출을 보장할 수 있음.

코드의 실행을 지연시키는 또 다른 API는 setImmediate()임.

process.nextTick()과 목적은 유사하지만 그 의미는 크게 다름.

process.nextTick()으로 지연된 콜백은 현재의 작업이 완료된 후에 바로 실행되며 다른 I/O 이벤트가 발생하기 전에 실행됨.

반면 setImmediate()는 이미 큐에 있는 I/O 이벤트들의 뒤에 대기하게 됨.

## Node.js 콜백 규칙
Node.js에서 CPS API 및 콜백은 일련의 특정한 규칙을 따름.

### 콜백은 맨 마지막에
모든 Node.js 코어 함수에서 표준 규칙은 함수가 입력으로서 콜백을 허용한다면 콜백이 맨 마지막 인자로 전달되어야 한다는 것

```js
readFile(filename, [options], callback)
```

이 함수의 특성에서 볼 수 있듯이 여러 인자가 있는 경우에도 콜백은 항상 마지막 위치에 놓임.

이 규칙이 존재하는 이유는 함수 호출의 가독성이 더 좋기 때문.

### 오류는 맨 처음에
Node.js에서 CPS 함수에 의해 생성된 오류는 항상 콜백의 첫 번째 인자로 전달되며, 실제 결과는 두번째 인자에서부터 전달.

동작이 에러 없이 성공하였을 때, 첫 번째 인자는 null 또는 undefined가 됨.

에러가 있는지 항상 체크하는 것이 좋음.

그렇지 않으면 코드를 디버깅하고 에러 지점을 찾는 것이 어려울 수 있음.

### 오류 전파
동기식 직접 스타일 함수의 오류 전파는 잘 알려진 throw문을 사용하여 수행되므로 오류가 catch 될 때까지 호출 스택에서 실행

비동기식 CPS에서 적절한 에러 전파는 오류를 호출 체인의 다음에서 콜백으로 전달하여 수행.

### 캐치되지 않는 예외
때때로 비동기 함수의 콜백 내에서 에러는 밖으로 전달되거나 포착되지 않는 상황이 발생.

비동기식 콜백 내부에서 예외를 발생시키는 것은 예외가 이벤트 루프로 이동하게 만들며 이것은 절대 다음 콜백으로 전파되지 않게 됨.

Node.js에서는 이것이 회복 불능 상태이며 애플리케이션은 0이 아닌 종료 코드와 함께 그냥 종료되고 stderr 인터페이스를 통해 오류를 출력.

에러는 비동기식 실행을 발생시키는 함수 안에서가 아니고 이벤트 루프에 예외가 발생한 별도의 콜 스택을 타고 올라감.

우리는 어플리케이션이 중단되기 이전에 자원을 정리하거나 로그를 남길 수 있음.

Node.js는 프로세스를 종료하기 직전에 uncaughtException이라는 특수 이벤트를 내보냄.

캐치되지 않는 예외가 애플리케이션의 일관성을 보장할 수 없는 상태로 만듬.

이로인해 예기치 않는 문제가 발생할 수 있음을 이해하는 것이 중요함.

여전히 불완전한 I/O 요청이 실행 중이거나 클로저가 일치하지 않을 수 있음.

### 정리
| 구분        | 설명                                                                 |
|-----------|--------------------------------------------------------------------|
| **발생 원인** | 비동기 콜백 내부에서 예외 발생 시 콜스택이 분리되어 `try/catch`로 감싸지지 않음                 |
| **전파 방식** | 이벤트 루프의 최상위까지 올라감 → Node.js가 `uncaughtException` 이벤트 방출            |
| **결과**    | 프로세스는 복구 불가능 상태로 판단 → 종료                                           |
| **대응법**   | `process.on('uncaughtException')`으로 로그 및 자원 정리 후 `process.exit(1)` |
| **예방**    | 모든 비동기 로직에 명시적인 `try/catch` 또는 `.catch()` 체인 추가                    |
