
# Chapter 03: 콜백과 이벤트

## 1. 콜백 패턴 (Callback Pattern)

Node.js 비동기 프로그래밍의 가장 기본적인 구성 요소입니다. 비동기 작업이 완료되었을 때 결과를 처리하기 위해 호출되는 함수입니다.

### 연속 전달 방식 (Continuation-Passing Style, CPS)
- 함수의 결과를 `return`하는 대신, 다른 함수(콜백)를 인자로 받아 그 함수에 결과를 전달하는 방식입니다.
- **동기식 CPS**: 코드가 순차적으로 실행되며 콜백도 동기적으로 호출됩니다.
- **비동기식 CPS**: 비동기 작업(e.g., `setTimeout`, `fs.readFile`)이 완료된 후 이벤트 루프의 다른 사이클에서 콜백이 호출됩니다. 이로 인해 코드의 실행 순서가 예측과 달라질 수 있습니다.

### 콜백의 위험요소: Zalgo
- **일관성 없는 API**: 어떤 조건에서는 동기적으로, 다른 조건에서는 비동기적으로 콜백을 호출하는 API는 예측 불가능한 버그를 유발할 수 있습니다. 이를 "Zalgo를 풀어놓는다"고 표현합니다.
- **해결책**:
    1. **완전한 동기 API**: `fs.readFileSync`처럼 항상 동기적으로만 동작하는 API를 제공합니다. (단, 이벤트 루프 블로킹 주의)
    2. **완전한 비동기 API (지연 실행)**: `process.nextTick()`이나 `setImmediate()`를 사용하여 콜백이 항상 현재 작업의 다음 사이클 이후에 비동기적으로 실행되도록 보장합니다. 이것이 Node.js에서 권장되는 방식입니다.

### Node.js 콜백 규칙
1.  **콜백은 마지막 인자**: 콜백 함수는 항상 API의 마지막 인자로 전달됩니다. (`readFile(path, options, callback)`)
2.  **오류는 첫 번째 인자**: 콜백 함수의 첫 번째 인자는 항상 에러 객체(`Error` 타입)입니다. 에러가 없으면 `null` 또는 `undefined`가 전달됩니다. (`(err, data) => { ... }`)
3.  **오류 전파**: 비동기 함수의 콜백 내에서 발생한 예외는 `try...catch`로 잡을 수 없습니다. 예외는 이벤트 루프로 전파되어 프로세스를 중단시킬 수 있습니다. 따라서 콜백 내의 오류는 다음 콜백으로 명시적으로 전달해야 합니다.

## 2. 관찰자 패턴 (Observer Pattern) & EventEmitter

하나의 이벤트에 대해 여러 개의 리스너(콜백)를 등록하고, 이벤트가 발생했을 때 모든 리스너에게 알림을 보내는 패턴입니다.

### EventEmitter 클래스
Node.js의 `events` 모듈에 내장된 클래스로, 관찰자 패턴을 쉽게 구현할 수 있게 해줍니다.
- **주요 메소드**:
    - `on(eventName, listener)`: 이벤트를 구독(리스너 등록).
    - `emit(eventName, [...args])`: 이벤트를 발생시켜 리스너들을 호출.
    - `once(eventName, listener)`: 이벤트를 한 번만 구독.
    - `removeListener(eventName, listener)`: 리스너를 제거.
- **오류 처리**: `error` 이벤트는 특별하게 취급됩니다. `error` 이벤트가 발생했을 때 등록된 리스너가 없으면, 예외가 발생하여 Node.js 프로세스가 종료됩니다. 따라서 항상 `error` 이벤트에 대한 리스너를 등록하는 것이 좋습니다.

### 관찰 가능한 객체 만들기
- `EventEmitter`를 직접 사용하기보다는, 다른 클래스가 `EventEmitter`를 상속받아 관찰 가능한(Observable) 객체가 되도록 만드는 것이 일반적입니다. (e.g., `class MyClass extends EventEmitter { ... }`)

### EventEmitter와 메모리 누수
- 리스너가 더 이상 필요 없을 때 `removeListener`로 해제하지 않으면 메모리 누수의 원인이 됩니다. 특히 HTTP 요청과 같이 수명이 짧은 객체에 영구적인 리스너를 등록할 때 주의해야 합니다.
- 한 이벤트에 10개 이상의 리스너가 등록되면 EventEmitter는 잠재적인 메모리 누수를 경고합니다. (`setMaxListeners()`로 이 제한을 조절할 수 있습니다.)

## 3. EventEmitter vs 콜백

- **콜백**: 작업의 **결과**를 한 번 반환해야 할 때 사용합니다. (성공 또는 실패)
- **EventEmitter**: 동일한 이벤트가 **여러 번** 발생할 수 있거나, 하나의 사건에 대해 **여러 곳**에서 알림을 받아야 할 때 사용합니다.

두 가지를 결합하여, 콜백으로 최종 결과를 전달하면서 동시에 EventEmitter로 중간 과정의 상태를 알리는 강력한 패턴을 만들 수도 있습니다. (e.g., `glob` 패키지)
