## chapter 3 느낀점

#### 1. Zalgo

- 챕터 3의 가장 핵심은 비동기 동기를 하나의 함수에서 동시에 쓰지 말라는 점이었다.
- 같이 쓰면 유지보수가 불가능한 예측불가능한 코드가 된다.
- 똑같이 비동기로 맞추어줄 때에는 nextTick 혹은 setImmediate을 쓰면된다. 타이밍 맞추려면 아래 루프 내에서 정확히 어떤 타이밍에 실행시킬지 고민하면된다.

#### 2. 세밀한 이벤트 루프 컨트롤

이벤트 루프 세부적으로 보면 다음과 같은 순서이다 (책에는 없다):

1. **콜스택(Call Stack)**이 비워짐 (예: 함수 실행이 끝나거나, 동기 코드를 모두 처리한 시점)
2. MicroTask 진행:
   1. process.nextTick() 큐 실행
      - nextTick은 Promise microtask보다 항상 먼저 실행됨.
      - process.nextTick()은 각 루프 단계 사이에서도 계속 비워짐.
   2. Promise Microtask Queue 실행
      - Promise.resolve().then(...) 등 비동기 콜백 실행.
3. MacroTask 진행:
   - Timers → Pending → Poll → Check → Close 순서로 진행.
     1. Timers — setTimeout(), setInterval()의 콜백 실행
     2. Pending Callbacks — 시스템에서 대기 중인 I/O 콜백 처리
     3. Idle, Prepare — 내부적으로 사용됨
     4. Poll — 새로운 I/O 이벤트 대기 및 처리
     5. Check — setImmediate() 콜백 실행
     6. Close Callbacks — socket.on('close', ...) 등 처리
   - 각 단계 후에도 다시 nextTick → microtasks 순서로 실행됨.

#### 3. node js 내에서의 콜백 파라미터 정의 컨벤션

1. 콜백은 마지막 인자로
2. 에러는 첫 인자로
3. 에러는 계속 다음 함수로 넘긴다.

- 나는 이게 express에서 만든 컨벤션인줄 알았는데, node.js에서 먼저 선행된 것으로 보여진다.
- 이거는 과연 아예 함수형 프로그래밍에서 추구하는 방향성일까 아니면 node.js 만들어질 때 임의로 설정한 것일까?

찾아보니 아래와 같다고 한다:

| 항목               | 설명                                                                     |
| ------------------ | ------------------------------------------------------------------------ |
| **기원**           | Node.js 설계 초기 (Ryan Dahl)                                            |
| **목적**           | 비동기 I/O의 단순하고 일관된 에러 처리                                   |
| **형태**           | `(error, result)` – error-first callback                                 |
| **Express와 관계** | Express는 Node.js 패턴을 계승함                                          |
| **FP와의 관계**    | CPS(continuation passing style)과 유사하지만, FP 철학의 직접 구현은 아님 |
| **장점**           | 명시적 에러 처리, 일관된 API, 이해하기 쉬운 흐름                         |
| **단점**           | 콜백 헬 문제 발생 → Promise / async-await로 발전                         |

#### 4. EventEmitter

- EventEmitter2는 라이브러리로 써봤는데, 원조가 node js 내장인줄은 몰랐다.
- 그냥 옵저버 패턴 구현체인것으로 보여진다. 그냥 리스너 목록이 있는것이기에 디폴트로는 동기적으로 동일 콜스택에서 실행될 것으로 예상된다.
- 비동기 콜백 + EventEmitter vs 비동기처리 뭘 쓸거냐 하면 사실 조금 자명한 편인 것 같다.

- 기본은 동기적이다.

  ```js
  const EventEmitter = require("events");
  const emitter = new EventEmitter();

  emitter.on("ping", () => {
    console.log("pong");
  });

  console.log("before");
  emitter.emit("ping");
  console.log("after");
  ```

  ```
  before
  pong
  after
  ```

- 이렇게 해야 비동기이다.

  ```js
  emitter.on("ping", async () => {
    await Promise.resolve(); // 혹은 nextTick, setImmediate
    console.log("pong");
  });

  console.log("before");
  emitter.emit("ping");
  console.log("after");
  ```

  ```
  before
  after
  pong
  ```
