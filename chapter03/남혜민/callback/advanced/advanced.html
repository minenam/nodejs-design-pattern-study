<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 03. 콜백과 이벤트 - 심화 학습</title>
    <link rel="stylesheet" href="advanced-styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>📚 Chapter 03. 콜백과 이벤트</h1>
            <p class="subtitle">Node.js 디자인 패턴 바이블 - 심화 학습</p>
        </header>

        <nav class="tabs">
            <button class="tab-btn active" data-tab="basics">기본 개념</button>
            <button class="tab-btn" data-tab="cps">CPS</button>
            <button class="tab-btn" data-tab="zalgo">Zalgo</button>
            <button class="tab-btn" data-tab="rules">콜백 규칙</button>
        </nav>

        <!-- 기본 개념 탭 -->
        <section id="basics" class="tab-content active">
            <h2>📖 기본 개념</h2>
            
            <div class="info-box">
                <h3>핵심 용어 정리</h3>
                <div class="term-grid">
                    <div class="term-card">
                        <h4>동기 (Synchronous)</h4>
                        <p>순차적으로 처리</p>
                        <div class="code-block">
                            <pre><code>console.log('1');
console.log('2');
console.log('3');
// 출력: 1 → 2 → 3</code></pre>
                        </div>
                    </div>
                    
                    <div class="term-card">
                        <h4>비동기 (Asynchronous)</h4>
                        <p>순차적이지 않음 (나중에 처리)</p>
                        <div class="code-block">
                            <pre><code>console.log('1');
setTimeout(() => console.log('2'), 0);
console.log('3');
// 출력: 1 → 3 → 2</code></pre>
                        </div>
                    </div>
                    
                    <div class="term-card">
                        <h4>블로킹 (Blocking)</h4>
                        <p>작업이 완료될 때까지 기다림</p>
                        <div class="code-block">
                            <pre><code>const data = fs.readFileSync('file.txt');
console.log(data);
console.log('다음 작업');</code></pre>
                        </div>
                    </div>
                    
                    <div class="term-card">
                        <h4>논블로킹 (Non-blocking)</h4>
                        <p>작업이 완료될 때까지 기다리지 않음</p>
                        <div class="code-block">
                            <pre><code>fs.readFile('file.txt', (err, data) => {
  console.log(data);
});
console.log('다음 작업');</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- CPS 탭 -->
        <section id="cps" class="tab-content">
            <h2>🔄 연속 전달 방식 (CPS, Continuation-Passing Style)</h2>
            
            <div class="definition-box">
                <h3>CPS란?</h3>
                <p><strong>단순히 결과를 반환하는 것 대신 다른 함수(콜백 함수)에 결과를 전달하는 프로그래밍 스타일</strong></p>
            </div>

            <div class="concept-box">
                <h3>비동기 연속 전달 방식</h3>
                
                <div class="code-block">
                    <pre><code>function addAsync(a, b, callback) {
  setTimeout(() => callback(a + b), 1000);
}

console.log("Start");
addAsync(2, 3, (result) => {
  console.log(`Result: ${result}`);
});
console.log("End");

// 출력 순서:
// Start
// End
// Result: 5</code></pre>
                </div>

                <div class="demo-section">
                    <h4>🎬 실행 흐름 시뮬레이션</h4>
                    <button id="runCPSDemo" class="btn-primary">실행</button>
                    <button id="resetCPSDemo" class="btn-secondary">리셋</button>
                    
                    <div class="flow-visualization">
                        <div class="flow-column">
                            <h5>Call Stack</h5>
                            <div id="cpsStack" class="flow-area"></div>
                        </div>
                        
                        <div class="flow-column">
                            <h5>Web APIs (Timer)</h5>
                            <div id="cpsTimer" class="flow-area"></div>
                        </div>
                        
                        <div class="flow-column">
                            <h5>Callback Queue</h5>
                            <div id="cpsQueue" class="flow-area"></div>
                        </div>
                    </div>
                    
                    <div id="cpsOutput" class="output-console">
                        <h5>Console 출력:</h5>
                        <div id="cpsOutputContent"></div>
                    </div>
                </div>
            </div>

            <div class="concept-box">
                <h3>핵심 원리</h3>
                
                <div class="principle-card">
                    <h4>비동기 작업 완료 시</h4>
                    <p>실행은 비동기 함수에 제공된 <strong>콜백에서부터 실행이 재개</strong>된다.</p>
                    <p>실행은 <strong>이벤트 루프에서 시작</strong>되어, <strong>새로운 스택</strong>을 가진다.</p>
                </div>
                
                <div class="principle-card">
                    <h4>클로저의 역할</h4>
                    <p>클로저 덕분에 콜백이 <strong>다른 시점과 다른 위치</strong>에서 호출되더라도</p>
                    <p>비동기 함수의 <strong>호출자 컨텍스트를 유지</strong>한다.</p>
                </div>
                
                <div class="comparison-box">
                    <div class="compare-item">
                        <h4>동기 함수</h4>
                        <p>조작 완료할 때까지 <strong>기다림</strong></p>
                        <div class="code-block">
                            <pre><code>function add(a, b) {
  return a + b;
}

const result = add(2, 3);
console.log(result); // 5</code></pre>
                        </div>
                    </div>
                    
                    <div class="compare-item">
                        <h4>비동기 함수</h4>
                        <p><strong>제어를 즉시 반환</strong>, 이벤트 루프 다음 사이클에서 핸들러(콜백)으로 결과를 전달</p>
                        <div class="code-block">
                            <pre><code>function addAsync(a, b, callback) {
  setTimeout(() => {
    callback(a + b);
  }, 1000);
}

addAsync(2, 3, (result) => {
  console.log(result); // 5
});</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-box">
                <h3>비연속 전달(Non-CPS) 방식</h3>
                
                <div class="code-block">
                    <pre><code>const result = [1, 3, 5].map((x) => x * 2);
console.log(result); // [2, 6, 10]</code></pre>
                </div>
                
                <div class="explanation-box">
                    <p>콜백은 배열 내 요소를 <strong>반복하는데만 사용</strong>하고 연산 결과를 전달하진 않는다.</p>
                    <p><strong>직접적인 방식</strong>으로 동기적으로 반환</p>
                </div>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>구분</th>
                                <th>CPS</th>
                                <th>Non-CPS</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>결과 전달</td>
                                <td>콜백으로 전달</td>
                                <td>직접 반환</td>
                            </tr>
                            <tr>
                                <td>실행 방식</td>
                                <td>비동기 가능</td>
                                <td>동기적</td>
                            </tr>
                            <tr>
                                <td>사용 예</td>
                                <td>fs.readFile, setTimeout</td>
                                <td>Array.map, Array.forEach</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Zalgo 탭 -->
        <section id="zalgo" class="tab-content">
            <h2>👹 Zalgo: 예측 불가능한 API</h2>
            
            <div class="definition-box danger">
                <h3>Zalgo란?</h3>
                <p><strong>비동기와 동기 API를 명확하게 정의하지 않고 혼재</strong>되어</p>
                <p><strong>호출 결과가 예측할 수 없는 상황</strong></p>
                <p class="reference">참고: <a href="https://blog.izs.me/2013/08/designing-apis-for-asynchrony/" target="_blank">Isaac Z. Schlueter - Designing APIs for Asynchrony</a></p>
            </div>

            <div class="concept-box">
                <h3>🎬 Zalgo 문제 시뮬레이션</h3>
                
                <div class="demo-controls">
                    <button id="runZalgoSync" class="btn-danger">캐시 있음 (동기) 실행</button>
                    <button id="runZalgoAsync" class="btn-warning">캐시 없음 (비동기) 실행</button>
                    <button id="resetZalgo" class="btn-secondary">리셋</button>
                </div>
                
                <div class="code-display">
                    <h4>문제가 있는 코드:</h4>
                    <div class="code-block bad">
                        <pre><code>const cache = {};

function getData(key, callback) {
  if (cache[key]) {
    callback(cache[key]); // 동기적으로 즉시 실행!
  } else {
    fetchFromDB(key, (data) => {
      cache[key] = data;
      callback(data); // 비동기적으로 나중에 실행!
    });
  }
}

let isReady = false;
getData('user:1', (data) => {
  console.log('isReady:', isReady);
});
isReady = true;</code></pre>
                    </div>
                </div>
                
                <div class="flow-visualization">
                    <div class="flow-column">
                        <h5>Call Stack</h5>
                        <div id="zalgoStack" class="flow-area"></div>
                    </div>
                    
                    <div class="flow-column">
                        <h5>Web APIs / I/O</h5>
                        <div id="zalgoWebAPI" class="flow-area"></div>
                    </div>
                    
                    <div class="flow-column">
                        <h5>Callback Queue</h5>
                        <div id="zalgoQueue" class="flow-area"></div>
                    </div>
                </div>
                
                <div id="zalgoOutput" class="output-console">
                    <h5>실행 결과:</h5>
                    <div id="zalgoOutputContent"></div>
                </div>
            </div>

            <div class="concept-box">
                <h3>⚠️ 주의사항</h3>
                
                <div class="warning-card">
                    <h4>동기 API 사용 시</h4>
                    <ul>
                        <li>함수가 동기식이면 함수가 CPS 스타일을 가질 필요가 없음</li>
                        <li><strong>직접 스타일로 구현하는 것이 최선</strong></li>
                    </ul>
                </div>
                
                <div class="warning-card">
                    <h4>동기 API의 문제점</h4>
                    <ul>
                        <li>항상 사용할 수 있지 않음</li>
                        <li><strong>이벤트 루프를 블록</strong>하고 동시 요청을 보류함</li>
                        <li>동시성 모델을 위반하여 <strong>애플리케이션 속도가 저하</strong>될 수 있음</li>
                        <li>비동기 동시성 작업을 처리하는데 영향을 주지않는 선에서 블로킹 API를 사용하는 것이 중요</li>
                    </ul>
                </div>
            </div>

            <div class="concept-box">
                <h3>✅ 해결 방법</h3>
                
                <div class="solution-tabs">
                    <button class="solution-tab active" data-solution="nextTick">process.nextTick()</button>
                    <button class="solution-tab" data-solution="immediate">setImmediate()</button>
                </div>
                
                <div id="nextTick" class="solution-content active">
                    <h4>process.nextTick()</h4>
                    
                    <div class="code-block good">
                        <pre><code>function getData(key, callback) {
  if (cache[key]) {
    // 동기 실행을 비동기로 변경
    process.nextTick(() => {
      callback(cache[key]);
    });
  } else {
    fetchFromDB(key, (data) => {
      cache[key] = data;
      callback(data);
    });
  }
}</code></pre>
                    </div>
                    
                    <div class="explanation-box">
                        <h5>동작 원리</h5>
                        <ul>
                            <li>현재 진행중 작업의 <strong>완료 시점 뒤로 함수의 실행을 지연</strong>시킴</li>
                            <li>콜백 인수를 받아 <strong>대기 중인 I/O 이벤트 대기열 앞에 삽입</strong> 후 반환</li>
                            <li>현재 진행 작업이 제어를 이벤트 루프로 넘기는 <strong>즉시 콜백이 실행</strong>됨</li>
                        </ul>
                    </div>
                    
                    <div class="warning-box">
                        <h5>⚠️ 주의: I/O 기아(Starvation)</h5>
                        <p>지연된 콜백(<strong>마이크로태스크</strong>)는 현재 작업 완료되면 바로 실행되고</p>
                        <p>다른 I/O 작업(<strong>매크로태스크</strong>)보다 우선 실행됨</p>
                        <p><strong>재귀호출</strong>과 같은 상황에서 I/O 기아 현상을 초래할 수 있음</p>
                    </div>
                    
                    <button id="runNextTickDemo" class="btn-success">process.nextTick 시뮬레이션</button>
                </div>
                
                <div id="immediate" class="solution-content">
                    <h4>setImmediate()</h4>
                    
                    <div class="code-block good">
                        <pre><code>function getData(key, callback) {
  if (cache[key]) {
    setImmediate(() => {
      callback(cache[key]);
    });
  } else {
    fetchFromDB(key, (data) => {
      cache[key] = data;
      callback(data);
    });
  }
}</code></pre>
                    </div>
                    
                    <div class="explanation-box">
                        <h5>동작 원리</h5>
                        <ul>
                            <li><strong>현재 이벤트 루프 사이클이 완료된 후</strong> 콜백을 실행</li>
                            <li><strong>I/O 이벤트 대기열 뒤에</strong> 콜백을 삽입</li>
                            <li>process.nextTick보다 우선순위가 낮음</li>
                        </ul>
                    </div>
                    
                    <div class="comparison-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>구분</th>
                                    <th>process.nextTick</th>
                                    <th>setImmediate</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>실행 시점</td>
                                    <td>현재 작업 완료 직후</td>
                                    <td>다음 이벤트 루프 사이클</td>
                                </tr>
                                <tr>
                                    <td>우선순위</td>
                                    <td>높음 (마이크로태스크)</td>
                                    <td>낮음 (매크로태스크)</td>
                                </tr>
                                <tr>
                                    <td>I/O 기아</td>
                                    <td>발생 가능</td>
                                    <td>발생 안 함</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- 콜백 규칙 탭 -->
        <section id="rules" class="tab-content">
            <h2>📋 Node.js 콜백 규칙</h2>
            
            <div class="concept-box">
                <h3>규칙 1: 콜백은 항상 맨 마지막 인수로 사용</h3>
                
                <div class="code-block good">
                    <pre><code>readFile(filename, encoding, callback);
//                              ↑ 마지막 인수</code></pre>
                </div>
                
                <div class="example-grid">
                    <div class="example-card">
                        <h4>✅ 올바른 예</h4>
                        <div class="code-block">
                            <pre><code>fs.readFile('file.txt', 'utf8', (err, data) => {
  console.log(data);
});

db.query('SELECT * FROM users', params, (err, rows) => {
  console.log(rows);
});</code></pre>
                        </div>
                    </div>
                    
                    <div class="example-card">
                        <h4>❌ 잘못된 예</h4>
                        <div class="code-block bad">
                            <pre><code>// 콜백이 중간에 위치
fs.readFile((err, data) => {
  console.log(data);
}, 'file.txt', 'utf8');

// 일관성 없음
db.query(callback, 'SELECT * FROM users');</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-box">
                <h3>규칙 2: 에러 우선 콜백 패턴 (Error-First Callback Pattern)</h3>
                
                <div class="principle-card">
                    <ul>
                        <li><strong>첫 번째 인수</strong>는 에러 객체 또는 null</li>
                        <li><strong>두 번째 인수</strong>는 정상 결과 값</li>
                    </ul>
                </div>
                
                <div class="code-block good">
                    <pre><code>fs.readFile("file.txt", (err, data) => {
  if (err) {
    // 에러 처리
    console.error('파일 읽기 실패:', err);
    return;
  }
  // 정상 처리
  console.log('파일 내용:', data);
});</code></pre>
                </div>
                
                <div class="demo-section">
                    <h4>🎬 에러 처리 시뮬레이션</h4>
                    <div class="demo-controls">
                        <button id="runErrorSuccess" class="btn-success">성공 케이스</button>
                        <button id="runErrorFail" class="btn-danger">실패 케이스</button>
                    </div>
                    
                    <div class="flow-visualization">
                        <div class="flow-column full-width">
                            <h5>실행 흐름</h5>
                            <div id="errorFlowArea" class="flow-area"></div>
                        </div>
                    </div>
                    
                    <div id="errorOutput" class="output-console">
                        <h5>실행 결과:</h5>
                        <div id="errorOutputContent"></div>
                    </div>
                </div>
            </div>

            <div class="concept-box">
                <h3>규칙 3: 에러(오류) 전파</h3>
                
                <div class="explanation-box">
                    <p>콜백을 사용하여 <strong>이벤트 루프의 예외가 발생한 별도 콜 스택으로 전파</strong></p>
                </div>
                
                <div class="code-block good">
                    <pre><code>function readJSON(filename, callback) {
  fs.readFile(filename, 'utf8', (err, data) => {
    if (err) {
      // 에러를 그대로 전파
      return callback(err);
    }
    
    let parsed;
    try {
      parsed = JSON.parse(data);
    } catch (parseErr) {
      // 파싱 에러도 콜백으로 전파
      return callback(parseErr);
    }
    
    // 성공
    callback(null, parsed);
  });
}

// 사용
readJSON('config.json', (err, config) => {
  if (err) {
    // 모든 에러를 한 곳에서 처리
    console.error('설정 로드 실패:', err);
    return;
  }
  console.log('설정:', config);
});</code></pre>
                </div>
                
                <div class="warning-box">
                    <h4>⚠️ try-catch는 비동기 에러를 잡을 수 없음</h4>
                    <div class="comparison-grid">
                        <div class="compare-item">
                            <h5>❌ 잘못된 예</h5>
                            <div class="code-block bad">
                                <pre><code>try {
  fs.readFile('file.txt', (err, data) => {
    if (err) throw err;
    // 이 에러는 try-catch 밖에서 발생!
  });
} catch (err) {
  // 여기서 잡히지 않음
  console.error(err);
}</code></pre>
                            </div>
                        </div>
                        
                        <div class="compare-item">
                            <h5>✅ 올바른 예</h5>
                            <div class="code-block good">
                                <pre><code>fs.readFile('file.txt', (err, data) => {
  if (err) {
    // 콜백 내에서 에러 처리
    handleError(err);
    return;
  }
  
  try {
    // 동기 코드의 에러만 try-catch
    const parsed = JSON.parse(data);
    processData(parsed);
  } catch (parseErr) {
    handleError(parseErr);
  }
});</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="concept-box">
                <h3>규칙 4: Fail-Fast 접근법</h3>
                
                <div class="definition-box">
                    <p><strong>에러가 발생하면 즉시 처리하고 종료</strong></p>
                </div>
                
                <div class="code-block good">
                    <pre><code>function processData(data, callback) {
  // 입력 검증 - 즉시 실패
  if (!data) {
    return callback(new Error('Data is required'));
  }
  
  if (typeof data !== 'object') {
    return callback(new Error('Data must be an object'));
  }
  
  // 비동기 작업
  saveToDatabase(data, (err, result) => {
    if (err) {
      // 에러 발생 시 즉시 반환
      return callback(err);
    }
    
    // 성공
    callback(null, result);
  });
}</code></pre>
                </div>
                
                <div class="benefit-box">
                    <h4>Fail-Fast의 장점</h4>
                    <ul>
                        <li>문제를 <strong>조기에 발견</strong>하여 디버깅이 쉬움</li>
                        <li>불필요한 작업을 <strong>방지</strong>하여 리소스 절약</li>
                        <li>에러 처리가 <strong>명확</strong>하고 예측 가능</li>
                        <li>시스템의 <strong>안정성</strong> 향상</li>
                    </ul>
                </div>
                
                <div class="demo-section">
                    <h4>🎬 Fail-Fast 시뮬레이션</h4>
                    <div class="demo-controls">
                        <button id="runFailFastValid" class="btn-success">유효한 데이터</button>
                        <button id="runFailFastInvalid" class="btn-danger">유효하지 않은 데이터</button>
                    </div>
                    
                    <div id="failFastOutput" class="output-console">
                        <h5>실행 결과:</h5>
                        <div id="failFastOutputContent"></div>
                    </div>
                </div>
            </div>

            <div class="concept-box">
                <h3>📝 콜백 규칙 요약</h3>
                
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-number">1</div>
                        <h4>콜백 위치</h4>
                        <p>항상 <strong>마지막 인수</strong></p>
                    </div>
                    
                    <div class="summary-card">
                        <div class="summary-number">2</div>
                        <h4>에러 우선</h4>
                        <p>첫 번째 인수는 <strong>에러</strong></p>
                    </div>
                    
                    <div class="summary-card">
                        <div class="summary-number">3</div>
                        <h4>에러 전파</h4>
                        <p>콜백으로 <strong>전파</strong></p>
                    </div>
                    
                    <div class="summary-card">
                        <div class="summary-number">4</div>
                        <h4>Fail-Fast</h4>
                        <p>에러 발생 시 <strong>즉시 처리</strong></p>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script src="advanced-script.js"></script>
</body>
</html>
